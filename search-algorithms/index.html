<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="stylesheet" href="/static/styles/global.css" />
  <link rel="stylesheet" href="/static/styles/code.css" />

  <link rel="icon" href="/static/icon/icon.svg" type="image/svg+xml">
  <link rel="shortcut icon" href="/static/icon/favicon.ico" />

  <link rel="alternate" type="application/rss+xml" href="https://notes.zachmanson.com/posts.xml" title="notes: posts" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta charset="UTF-8" />
  <title>notes: search algorithms</title>
</head>

<body>
  <nav>
    <div class="main-icon">
      <a href="/">
        <svg xmlns="http://www.w3.org/2000/svg" baseProfile="full" version="1.1" style="fill: none;"
          viewBox="26.88 56.87 216.25 156.27">
          <path
            style="stroke-width: 15px; stroke-linecap: butt; stroke-linejoin: round; stroke: rgb(10, 10, 10); fill: none;"
            d="M135,75 A60,60 0 0,0 75,135 A60,60 0 0,0 135,195 A60,60 0 0,0 195,135 A60,60 0 0,0 135,75 M45,90 A15,15 0 0,1 60,75 A15,15 0 0,1 75,90 L75,135 L75,180 A15,15 0 0,1 60,195 A15,15 0 0,1 45,180 M225,90 A15,15 0 0,0 210,75 A15,15 0 0,0 195,90 L195,135 L195,180 A15,15 0 0,0 210,195 L210,195 A15,15 0 0,0 225,180 M135,105 A30,30 0 0,1 165,135 A30,30 0 0,1 135,165 A30,30 0 0,1 105,135 A30,30 0 0,1 135,105 M45,105 L45,105 L45,165 M225,105 L225,105 L225,165 ">
          </path>
        </svg>
      </a>
    </div>

    <div class="nav-segments-container">
      <div class="nav-segments">
        
        <div class="nav-links piblings">
          
          
          
          <a href="/artificial-intelligence---a-modern-approach" class="activated-link">Artificial Intelligence - A Modern Approach</a>
          
          
          
          <a href="/practical-deep-learning">Practical Deep Learning</a>
          
          
          
          <a href="/uwa-computer-science">UWA Computer Science</a>
          
          
        </div>
        

        
        <div class="nav-links siblings">
          
          
          
          <a href="/aima-chapter-01">AIMA Chapter 01</a>
          

          
          
          <a href="/aima-chapter-02">AIMA Chapter 02</a>
          

          
          
          <a href="/aima-chapter-03">AIMA Chapter 03</a>
          

          
          
          <a href="/agents">Agents</a>
          

          
          
          <a href="/problem-solving-agents">Problem Solving Agents</a>
          

          
          
          <a href="/search-algorithms" class="activated-link">Search Algorithms</a>
          

          
          
          <a href="/task-environments">Task Environments</a>
          

          
        </div>
        

        
      </div>
    </div>
  </nav>

  <main>
    <header>
      <h1>Search Algorithms</h1>
    </header>

    <article><p>Search algorithms are methods of finding a certain node in a graph.  They require each node data structure to keep track of the tree:</p>
<ul>
<li>state</li>
<li>parent</li>
<li>action</li>
<li>path-cost</li>
</ul>
<p>There also must be a data structure containing the frontier of nodes that are net to be explored, usually a queue.</p>
<p>Search algorithms need to account for redundant paths, including primarily cycles.  Graph search algorithms account for this, tree like searches do not.  Finding all redundant paths is generally expensive, so usually only cycles are worried.</p>
<p>Search algorithms can be evaluated by:</p>
<ul>
<li>completeness</li>
<li>cost optimality</li>
<li>time complexity</li>
<li>space complexity</li>
</ul>
<p>Problems have depth and branching factor which impact the importance of algorithmic time/space complexity.</p>
<p>Best-first search is a general search algorithm where the next node to be explored is that with the smallest value from an eval-function. New children are added to frontier when they are discovered, and are readded if a new lower cost path is them are discovered.  Different evaluation functions can be used to create other search algorithms. </p>
<h2 id="uninformed-search-strategies">Uninformed Search Strategies</h2>
<ul>
<li>Breadth-first search<ul>
<li>best used when all actions have the same cost</li>
<li>best used with FIFO queue unless there are additional heuristics in place</li>
<li>always finds most efficient solution</li>
</ul>
</li>
<li>Dijkstraâ€™s algorithm, aka uniform-cost search<ul>
<li>best first search where eval is the cost path from root to current node</li>
</ul>
</li>
<li>depth-first search<ul>
<li>goes deep first</li>
<li>often poor for graph search since, work well in finite space tree environments</li>
<li>is not cost optimal, may not find best solution</li>
<li>has small memory requirements</li>
<li>can be modified to be more memory efficient using backtracking search</li>
<li>can also have a depth limit to cap complexity, or iteratively deepened</li>
</ul>
</li>
<li>bidirectional search<ul>
<li>searches from the initial and the goal state simultaneously, hoping the tow of them will meet</li>
</ul>
</li>
</ul>
<h2 id="informed-search-strategies">Informed Search Strategies</h2>
<p>Heuristic functions can give domain-specific hints to an algorithm.</p>
<ul>
<li>greedy best first search<ul>
<li>expands the first node with the lowest h(n) value, so <code>f(n) = h(n)</code></li>
<li>complete for finite spaces, quality of heuristic function matters a lot</li>
</ul>
</li>
<li>A* search<ul>
<li><code>f(n) = g(n) + h(n)</code></li>
<li>g(n) is the path cost from the initial state to node n</li>
<li>h(n) is the estimate cost of the shortest path from n to goal</li>
<li>A* is search complete</li>
<li>if the heuristic is <strong>admissible</strong> (never overestimates the cost to reach a goal), A* is cost optimal</li>
<li>if a heuristic is <strong>consistent</strong> if each node n and successor n' generated by action a  <code>h(n) &lt;= cost(n,a,n')+h(n')</code><ul>
<li>all consistent heuristics are admissible</li>
<li>also when reaching a node it will always be optimal path</li>
</ul>
</li>
<li>without admissibility, A* may not be cost optimal</li>
<li>it prunes nodes that won't be used in an optimal solution</li>
</ul>
</li>
<li>weighted A* search<ul>
<li><code>f(n) = g(n) + W * h(n)</code>, heuristic is more important</li>
<li>h(n) may overestimate but it may be more accurate</li>
</ul>
</li>
<li>beam search limits the size of the frontier based on best f-score</li>
<li>iterative deepening A*<ul>
<li>the cutoff for this is f-cost</li>
<li>if all nodes have different f-cost, then each deepening may only have 1 new node which is slow</li>
<li>ends up exploring the same space repeatedly</li>
</ul>
</li>
<li>recursive best-first search<ul>
<li>best-first search but with linear space, uses the f limit to keep track of the f-value of the best alternative path from any ancestor of current node</li>
<li>allows it to backtrack without storing the entire alternate tree, only storing remembering the best f-score from that tree</li>
<li>is optimal if h(n) is admissible</li>
<li>time complexity is a hrd thing to explain</li>
<li>ends up exploring the same space repeatedly</li>
</ul>
</li>
<li>SMA*<ul>
<li>has limited memory for leaves, will drop worst f-value leaf as it expands</li>
<li>only needs to regenerate tree when entire subtree when all other paths are look worse than the path that was forgotten</li>
<li>when there is a f-value draw it it will drop the oldest</li>
<li>is complete for all solutions within memory bounds, and for those it is optimal</li>
<li>on hard problems it goes back and forth between small subset of candidates that can fit in memory</li>
</ul>
</li>
<li>bidirectional heuristic search<ul>
<li>to prove optimal cost solutions, we must consider pairs of nodes, one from either frontier that can be proved to be surely expanded</li>
<li>no guarantee of optimal efficiency, even after you have determined that a pair of nodes are both surely expanded, since you do not know which of their children to follow</li>
</ul>
</li>
</ul>
<blockquote>
<p>all nodes that can be reached from the initial state on a path where every node on the path has <code>f(n) &lt; C*</code>. We say these are surely expanded nodes</p>
</blockquote>
<p><cite class="standalone">AIMA Chapter 3, pg. 90</cite></p>
<h2 id="heuristics">Heuristics</h2>
<p>An important characteristic is the effective branching factor (b<em>) of a heuristic. Ideally b</em> is close to 1.</p></article>
  </main>

  <footer>
    <details>
      <summary>
        <div class="footer-row">
          
          meta
          
          <a href="/recent-changes">recent</a>
          <a href="/do-things-tell-people" class="not-extra-small">random</a>
          <a href="/posts">posts</a>
          <a href="/sitemap" class="not-extra-small">sitemap</a>
          <a href="https://github.dev/zachpmanson/notes/blob/main/./notes/Notes/Courses/Artificial Intelligence - A Modern Approach/Search Algorithms.md" class="desktop">edit</a>
          <a href="https://github.com/zachpmanson/notes/edit/main/./notes/Notes/Courses/Artificial Intelligence - A Modern Approach/Search Algorithms.md" class="mobile">edit</a>
          <a href="mailto:zachpmanson@gmail.com?subject=On 'Search Algorithms'">reply</a>
        </div>
      </summary>
      <div class="extra-small">
        <div class="footer-row">
          <a href="/sitemap">sitemap</a>
          <a href="/do-things-tell-people">random</a>
        </div>
      </div>

      

      
      <p>
        

        <span class="backlinks">
          <strong>
            Updated:
          </strong>
          <date>2024-04-28</date>
        </span>

      </p>
    </details>

  </footer>
  
  <script type="module">
    let allActivatedLinks = document.querySelectorAll(".activated-link");

    function checkVisible(el) {
      let rect = el.getBoundingClientRect();
      let viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
      return !(rect.bottom < 0 || rect.top - viewHeight >= 0);
    }


    function scrollActivatedLinksIntoView(behavior="smooth") {
      for (let link of allActivatedLinks) {
        if (checkVisible(link.parentElement)) {
          link.scrollIntoView({behavior: behavior, block: "center", inline: "nearest"});
        }
      }
    }
    
    document.querySelector("nav").addEventListener("mouseleave", ()=>{
      setTimeout(scrollActivatedLinksIntoView, 350);
    });
    scrollActivatedLinksIntoView();
  </script>
</body>

</html>